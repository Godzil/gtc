
#var FALSE D(0)
#var TRUE D(1)

#var ERROR_FRAME typedef struct ErrorFrameStruct{unsigned long A2,A3,A4,A5,A6,A7;unsigned long D3,D4,D5,D6,D7;unsigned long NG_control;char*RetIndex;unsigned long PC;struct ErrorFrameStruct*Link;}ERROR_FRAME[1];
#var ER_OK D(0)
#var ER_OKAY D(0)
#var ER_EXIT D(1)
#var ER_STOP D(2)
#var ER_OFF D(3)
#var ER_PRGM_STOP D(4)
#var ER_NO_MSG D(9)
#var ER_ARGUMENT D(40)
#var ER_BREAK D(180)
#var ER_MEMORY D(670)
#var ER_MEMORY_EXHAUSTION D(670)
#var ER_ESTACK_OVERFLOW D(670)
#var ER_STACK_VIO D(673)
#var ER_SYNTAX D(910)
#var ER_TOO_FEW_ARGS D(930)
#var ER_TOO_MANY_ARGS D(940)

#var ER_catch D(_rom_call(short,(void*),154))
#var ER_success D(_rom_call(void,(void),155))
#var ER_throw(err_no) D(asm volatile{dc.w 0xA000+(err_no)})
#var ER_throwVar D((*({typedef void(*__temp__type__)(short)__ATTR_TIOS_NORETURN__;(__temp__type__)(_rom_call_addr(153));})))
#var ERD_dialog D(_rom_call(short,(short,short),151))
#var ERD_process D(_rom_call(void,(short),152))
#var ENDFINAL D(}if(errCode)PASS;})
#var ENDTRY D(;_ONERR_=0;}})
#var FINALLY D(ER_success();}{)
#var ONERR D(ER_success();}else{register short _ONERR_=1;)
#var PASS D((ER_throwVar(errCode)))
#var TRY D({ERROR_FRAME __errFrame;unsigned short errCode;errCode=ER_catch(__errFrame);if(!errCode){)
#var find_error_message D(_rom_call(const char*,(short),2C1))

#var ER_THROW(n) D(ER_throw(n))
